<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZEALP TECH COMMUNITY</title>
  <subtitle>多思、寡言、极简</subtitle>
  <link href="/ZealP_Blog/atom.xml" rel="self"/>
  
  <link href="https://zealp.github.io/ZealP_Blog/"/>
  <updated>2019-01-14T17:13:18.187Z</updated>
  <id>https://zealp.github.io/ZealP_Blog/</id>
  
  <author>
    <name>ZealP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin设计模式之Builder模式</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/15/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/15/kotlin设计模式之Builder模式/</id>
    <published>2019-01-14T16:42:12.000Z</published>
    <updated>2019-01-14T17:13:18.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kotlin设计模式之Builder模式"><a href="#Kotlin设计模式之Builder模式" class="headerlink" title="Kotlin设计模式之Builder模式"></a>Kotlin设计模式之Builder模式</h2><h3 id="Builder模式介绍"><a href="#Builder模式介绍" class="headerlink" title="Builder模式介绍"></a>Builder模式介绍</h3><p>Builder模式是将一个复杂对象的创建与它的表示分离，使得同样的构建过程可以创建不同的表示。因为一个复杂的对象由大量的组件组成，为了在构建过程中对外部隐藏实现细节，使用Builder模式将部件和组装分离，使得构建过程和部件都可以自由扩展，两者之间的耦合能降到最低。</p>
<p>Builder模式的使用场景：</p>
<ol>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时使用。</li>
<li>多个部件或零件，都可以装配到一个对象中，但产生的运行结果又不相同时。</li>
<li>产品类非常复杂，或产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者形式非常合适。</li>
<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</li>
</ol>
<p>Builder模式在Android源码和第三方库中出现率很高，比如Android源码中的AlertDialog组件就是使用的Builder模式进行构建的。</p>
<h3 id="Builder模式在实际开发中的实现"><a href="#Builder模式在实际开发中的实现" class="headerlink" title="Builder模式在实际开发中的实现"></a>Builder模式在实际开发中的实现</h3><p>我们以一个机器人的建造来看看Builder模式在项目中的实践</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> robotConfig: RobotDynamicConfig? = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置动态配置的机器人组件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setRobotDynamicConfig</span><span class="params">(config: <span class="type">RobotDynamicConfig</span>)</span></span> &#123;</div><div class="line">        robotConfig = config</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取机器人信息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRobotInfo</span><span class="params">()</span></span>&#123;</div><div class="line">        println(<span class="string">"工厂当前生产的是战争机器人是个非常厉害的杀人机器,"</span> +</div><div class="line">                <span class="string">"它配备的主武器和副武器分别为<span class="subst">$&#123;robotConfig?.mainArms&#125;</span>和<span class="subst">$&#123;robotConfig?.viceArms&#125;</span>，"</span> +</div><div class="line">                <span class="string">"它全身使用的材质主要为行业最新科技<span class="subst">$&#123;robotConfig?.material&#125;</span>，"</span> +</div><div class="line">                <span class="string">"它的能量核心使用的是<span class="subst">$&#123;robotConfig?.energy&#125;</span>，"</span> +</div><div class="line">                <span class="string">"您觉得还满意吗？"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotDynamicConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主武器</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> mainArms = <span class="string">"手枪"</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 副武器</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> viceArms = <span class="string">"匕首"</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 材质</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> material = <span class="string">"铁"</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 动力来源</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> energy = <span class="string">"汽油"</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line"></div><div class="line">    <span class="keyword">object</span> Builder &#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 主武器</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> mainArms = <span class="string">"手枪"</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 副武器</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> viceArms = <span class="string">"匕首"</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 材质</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> material = <span class="string">"铁"</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 动力来源</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> energy = <span class="string">"汽油"</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 设置机器人主武器</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setMainArms</span><span class="params">(arms: <span class="type">String</span>?)</span></span>: Builder &#123;</div><div class="line">            <span class="keyword">if</span> (!arms.isNullOrEmpty())</div><div class="line">                mainArms = arms!!</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 设置机器人副武器</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setViceArms</span><span class="params">(arms: <span class="type">String</span>?)</span></span> : Builder&#123;</div><div class="line">            <span class="keyword">if</span> (!arms.isNullOrEmpty())</div><div class="line">                viceArms = arms!!</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 设置机器人材质</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setMaterial</span><span class="params">(material : <span class="type">String</span>?)</span></span> : Builder&#123;</div><div class="line">            <span class="keyword">if</span> (!material.isNullOrEmpty())</div><div class="line">                viceArms = material!!</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 设置机器人动力来源</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setEnergy</span><span class="params">(energy : <span class="type">String</span>?)</span></span> : Builder&#123;</div><div class="line">            <span class="keyword">if</span> (!energy.isNullOrEmpty())</div><div class="line">                viceArms = energy!!</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 复制数据到config文件里</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRobotConfig</span><span class="params">(config : <span class="type">RobotDynamicConfig</span>)</span></span>&#123;</div><div class="line">            config.mainArms = <span class="keyword">this</span>.mainArms</div><div class="line">            config.viceArms = <span class="keyword">this</span>.viceArms</div><div class="line">            config.material = <span class="keyword">this</span>.material</div><div class="line">            config.energy = <span class="keyword">this</span>.energy</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 创建完成，返回配置对象</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: RobotDynamicConfig&#123;</div><div class="line">            <span class="keyword">var</span> robotConfig = RobotDynamicConfig()</div><div class="line">            getRobotConfig(robotConfig)</div><div class="line">            <span class="keyword">return</span> robotConfig</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体调用的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">robotBuild</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">val</span> factory = RobotFactory()</div><div class="line">        <span class="keyword">val</span> robotConfig = RobotDynamicConfig</div><div class="line">                .Builder</div><div class="line">                .setMainArms(<span class="string">"电磁炮（ElectricGun)"</span>)</div><div class="line">                .setViceArms(<span class="string">"粒子光束（ParticleBeam）"</span>)</div><div class="line">                .setMaterial(<span class="string">"石墨烯(Graphene)"</span>)</div><div class="line">                .setEnergy(<span class="string">"零点能"</span>)</div><div class="line">                .build()</div><div class="line">        factory.setRobotDynamicConfig(robotConfig)</div><div class="line">        factory.getRobotInfo()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果:</p>
<blockquote>
<p>输出 : “工厂当前生产的是战争机器人是个非常厉害的杀人机器,它配备的主武器和副武器分别为电磁炮（ElectricGun)和粒子光束（ParticleBeam），它全身使用的材质主要为行业最新科技石墨烯(Graphene)，它的能量核心使用的是零点能，您觉得还满意吗？”</p>
</blockquote>
<p>代码的重点在Build类中，这是实现链式调用的实现写法。</p>
<p><em>本文来自阅读《Android Source Design Patterns Analysis &amp; Practice》书籍的笔记</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kotlin设计模式之Builder模式&quot;&gt;&lt;a href=&quot;#Kotlin设计模式之Builder模式&quot; class=&quot;headerlink&quot; title=&quot;Kotlin设计模式之Builder模式&quot;&gt;&lt;/a&gt;Kotlin设计模式之Builder模式&lt;/h2&gt;&lt;
    
    </summary>
    
    
      <category term="Kotlin设计模式" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin设计模式之单例模式</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/12/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/12/kotlin设计模式之单例模式/</id>
    <published>2019-01-12T05:42:12.000Z</published>
    <updated>2019-02-15T13:49:08.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kotlin设计模式之单例模式"><a href="#Kotlin设计模式之单例模式" class="headerlink" title="Kotlin设计模式之单例模式"></a>Kotlin设计模式之单例模式</h2><h3 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h3><p>单例模式在日常开发中是非常常见的写法，一般常见于全局只需要类保有一个对象实例用于使用的情景.避免了产生多个对象消耗过多的资源，或某种类型对象只应该有且只有一个。一般一个对象需要消耗的资源过多，比如访问IO和数据库等资源时就要考虑使用单例模式。</p>
<p>单例模式实现的要点是:<br>1.构造函数私有化，不对外开放<br>2.通过静态方法getInstance()或者枚举返回单例对象<br>3.确保在多线程环境下单例类对象有且只有一个<br>4.确保单例类对象在反序列化时不会重新构建对象</p>
<h3 id="下列几种单例模式是单例模式下最常见的几种写法"><a href="#下列几种单例模式是单例模式下最常见的几种写法" class="headerlink" title="下列几种单例模式是单例模式下最常见的几种写法"></a>下列几种单例模式是单例模式下最常见的几种写法</h3><h4 id="饿汉模式-每次都创建一个对象来赋值"><a href="#饿汉模式-每次都创建一个对象来赋值" class="headerlink" title="饿汉模式 每次都创建一个对象来赋值"></a>饿汉模式 每次都创建一个对象来赋值</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> mInstance: Singleton = Singleton()</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton &#123;</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="懒汉模式-不用每次都创建一个新的对象，可以复用已存在的对象-缺点是同步锁导致性能降低"><a href="#懒汉模式-不用每次都创建一个新的对象，可以复用已存在的对象-缺点是同步锁导致性能降低" class="headerlink" title="懒汉模式 不用每次都创建一个新的对象，可以复用已存在的对象, 缺点是同步锁导致性能降低"></a>懒汉模式 不用每次都创建一个新的对象，可以复用已存在的对象, 缺点是同步锁导致性能降低</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mInstance: Singleton2</div><div class="line">        <span class="meta">@Synchronized</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton2 &#123;</div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</div><div class="line">                mInstance = Singleton2()</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Double-Check-Lock-懒汉模式的升级版，不用每次都同步，在没有对象的时候才能同步-比懒汉模式的效率有提升-但这种单例模式还是有漏洞，存在一些问题"><a href="#Double-Check-Lock-懒汉模式的升级版，不用每次都同步，在没有对象的时候才能同步-比懒汉模式的效率有提升-但这种单例模式还是有漏洞，存在一些问题" class="headerlink" title="Double Check Lock 懒汉模式的升级版，不用每次都同步，在没有对象的时候才能同步,比懒汉模式的效率有提升,但这种单例模式还是有漏洞，存在一些问题"></a>Double Check Lock 懒汉模式的升级版，不用每次都同步，在没有对象的时候才能同步,比懒汉模式的效率有提升,但这种单例模式还是有漏洞，存在一些问题</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mInstance: Singleton3</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton3 &#123;</div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>) &#123;</div><div class="line">                synchronized(Singleton3::<span class="class"><span class="keyword">class</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</div><div class="line">                        mInstance = Singleton3()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="静态内部类单例-可以延迟内部对象的生成，并且是线程安全"><a href="#静态内部类单例-可以延迟内部对象的生成，并且是线程安全" class="headerlink" title="静态内部类单例 可以延迟内部对象的生成，并且是线程安全"></a>静态内部类单例 可以延迟内部对象的生成，并且是线程安全</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton4 &#123;</div><div class="line">            <span class="keyword">return</span> Singleton4Holder.mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTestValue</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"内部方法"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4Holder</span> </span>&#123;</div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="keyword">internal</span> <span class="keyword">val</span> mInstance: Singleton4 = Singleton4()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="枚举单例-枚举在任何情况下都是一个实例，同时枚举是线程安全的类"><a href="#枚举单例-枚举在任何情况下都是一个实例，同时枚举是线程安全的类" class="headerlink" title="枚举单例 枚举在任何情况下都是一个实例，同时枚举是线程安全的类"></a>枚举单例 枚举在任何情况下都是一个实例，同时枚举是线程安全的类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTestValue</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"内部方法"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：单例模式切忌使用于需要动态变化的实例场景下</p>
</blockquote>
<p><em>本文来自阅读《Android Source Design Patterns Analysis &amp; Practice》书籍的笔记</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kotlin设计模式之单例模式&quot;&gt;&lt;a href=&quot;#Kotlin设计模式之单例模式&quot; class=&quot;headerlink&quot; title=&quot;Kotlin设计模式之单例模式&quot;&gt;&lt;/a&gt;Kotlin设计模式之单例模式&lt;/h2&gt;&lt;h3 id=&quot;单例模式介绍&quot;&gt;&lt;a hr
    
    </summary>
    
    
      <category term="Kotlin设计模式" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>灵活开发之面向对象的六大原则</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/12/%E7%81%B5%E6%B4%BB%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/12/灵活开发之面向对象的六大原则/</id>
    <published>2019-01-12T05:24:45.000Z</published>
    <updated>2019-01-14T16:50:53.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灵活开发之面向对象的六大原则（SOLID原则-迪米特原则）"><a href="#灵活开发之面向对象的六大原则（SOLID原则-迪米特原则）" class="headerlink" title="灵活开发之面向对象的六大原则（SOLID原则 + 迪米特原则）"></a>灵活开发之面向对象的六大原则（SOLID原则 + 迪米特原则）</h2><h3 id="单一职责原则-让代码更清晰"><a href="#单一职责原则-让代码更清晰" class="headerlink" title="单一职责原则-让代码更清晰"></a>单一职责原则-让代码更清晰</h3><p>单一职责原则(Single Responsibility Principle)，简单来说一个类，一个函数只对应一种职责，只做一类事情。例如一个类里面不能包含多个完全不同类型功能的代码，同一个类应该保证方法对应的功能相关性高。但是单一职责原则划分界限不清晰，很多时候需要根据个人经验或者具体业务逻辑来界定。</p>
<h3 id="开闭原则-让程序更灵活、稳定"><a href="#开闭原则-让程序更灵活、稳定" class="headerlink" title="开闭原则-让程序更灵活、稳定"></a>开闭原则-让程序更灵活、稳定</h3><p>开闭原则(Open Close Principle)的定义是软件中的对象(类、模块、函数等)应对于扩展是开放的，对于修改是关闭的，也就是说编写代码的时候应该以编写新的扩展功能来替代在原代码上直接修改这种行为，因为软件的生命周期里出现变化、升级和维护都是必不可少的情况，直接在原代码基础上修改可能将原本无问题的代码引入错误进来，导致系统异常或者不稳定等情况。</p>
<h3 id="里氏替换原则-构建扩展性更好的系统"><a href="#里氏替换原则-构建扩展性更好的系统" class="headerlink" title="里氏替换原则-构建扩展性更好的系统"></a>里氏替换原则-构建扩展性更好的系统</h3><p>里氏替换原则(Liskov Substitution Principle)的定义是如果每个类型为S的对象obj1,都有类型为T的对象obj2，那么类型S是类型为T的子类。简单点说就是所有引用了父类对象的地方，都可以使用它的子类对象直接替代，这也是面向对象中的继承和多态的概念。<br>里氏替换原则的优缺点如下<br>优点：<br>1.代码重用性好，每个子类都可以直接继承父类的属性和方法，可直接使用父类属性和方法，也可重写父类方法<br>2.提高代码的可扩展性<br>缺点：<br>1.继承的侵入性，每个子类必需全部继承父类的所有属性和方法<br>2.因子类必需全部继承父类的所有属性和方法可能导致代码冗余、灵活性降低</p>
<h3 id="依赖倒置原则-让项目拥有变化的能力"><a href="#依赖倒置原则-让项目拥有变化的能力" class="headerlink" title="依赖倒置原则-让项目拥有变化的能力"></a>依赖倒置原则-让项目拥有变化的能力</h3><p>依赖倒置原则(Dependence Inversion Principle)其实是一种解耦的形式，主要提出高层模块不应该依赖低层模块，两者都应该直接依赖其抽象，并且抽象不应该依赖于细节，而细节必须依赖抽象。该原则在java中的表现是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生<br>的。简单点说就是将细节实现业务抽象成一个或多个共有的接口，通过接入接口来实现具体的细节类，并且在引用该接口的地方直接传入实现该接口的子类实现类，就可以实现符合开闭原则的依赖替换原则。</p>
<blockquote>
<p>耦合问题: 如果类与类直接依赖于细节，那么它们之间就有直接的耦合，当具体实现需要变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。</p>
</blockquote>
<h3 id="接口隔离原则-系统有更高的灵活性"><a href="#接口隔离原则-系统有更高的灵活性" class="headerlink" title="接口隔离原则-系统有更高的灵活性"></a>接口隔离原则-系统有更高的灵活性</h3><p>接口隔离原则(Interface Segregation Principles)的定义是实现类不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上，该原则将庞大、臃肿的接口拆分成更小更具体的接口，由客户来挑选了解他们感兴趣的方法。其实说简单了就是封装类提供出自己认为可以给客户使用的方法供客户使用，而不是将所有重要的或不被允许提供的方法提供给用户。</p>
<h3 id="迪米特原则-更好的可扩展性"><a href="#迪米特原则-更好的可扩展性" class="headerlink" title="迪米特原则-更好的可扩展性"></a>迪米特原则-更好的可扩展性</h3><p>迪米特原则(Law Of Demeter)也称为最少知识原则(Least Knowledge Principle)，该原则是指一个对象应该对其他对象有最少的了解，可就是说一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或依赖者无关，调用者或依赖者只需要知道它需要知道的方法即可，其他一概不用管。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><em>本文来自阅读《Android Source Design Patterns Analysis &amp; Practice》书籍的笔记</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;灵活开发之面向对象的六大原则（SOLID原则-迪米特原则）&quot;&gt;&lt;a href=&quot;#灵活开发之面向对象的六大原则（SOLID原则-迪米特原则）&quot; class=&quot;headerlink&quot; title=&quot;灵活开发之面向对象的六大原则（SOLID原则 + 迪米特原则）&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="Kotlin设计模式" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>2019 Kotlin Technology Stack</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/05/2019KotlinTechnologyStack/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/05/2019KotlinTechnologyStack/</id>
    <published>2019-01-05T15:10:48.000Z</published>
    <updated>2019-01-14T17:14:11.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《2019-Kotlin-Technology-Stack》笔记集之设计模式"><a href="#《2019-Kotlin-Technology-Stack》笔记集之设计模式" class="headerlink" title="《2019 Kotlin Technology Stack》笔记集之设计模式"></a>《2019 Kotlin Technology Stack》笔记集之设计模式</h2><p><a href="https://zealp.github.io/ZealP_Blog/2019/01/12/%E7%81%B5%E6%B4%BB%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/">灵活开发之面向对象的六大原则</a></p>
<p><a href="https://zealp.github.io/ZealP_Blog/2019/01/12/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">Kotlin设计模式之单例模式</a></p>
<p><a href="https://zealp.github.io/ZealP_Blog/2019/01/15/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/">Kotlin设计模式之Builder模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;《2019-Kotlin-Technology-Stack》笔记集之设计模式&quot;&gt;&lt;a href=&quot;#《2019-Kotlin-Technology-Stack》笔记集之设计模式&quot; class=&quot;headerlink&quot; title=&quot;《2019 Kotlin Tec
    
    </summary>
    
    
      <category term="Kotlin Tech Stack" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin-Tech-Stack/"/>
    
  </entry>
  
</feed>
