<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZEALP TECH COMMUNITY</title>
  <subtitle>多思、寡言、极简</subtitle>
  <link href="/ZealP_Blog/atom.xml" rel="self"/>
  
  <link href="https://zealp.github.io/ZealP_Blog/"/>
  <updated>2019-01-12T05:44:22.780Z</updated>
  <id>https://zealp.github.io/ZealP_Blog/</id>
  
  <author>
    <name>ZealP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin设计模式之单例模式</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/12/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/12/kotlin设计模式之单例模式/</id>
    <published>2019-01-12T05:42:12.000Z</published>
    <updated>2019-01-12T05:44:22.780Z</updated>
    
    <content type="html"><![CDATA[<p>#kotlin设计模式之单例模式</p>
<p>##单例模式介绍</p>
<p>单例模式在日常开发中是非常常见的写法，一般常见于全局只需要类保有一个对象实例用于使用的情景.避免了产生多个对象消耗过多的资源，或某种类型对象只应该有且只有一个。一般一个对象需要消耗的资源过多，比如访问IO和数据库等资源时就要考虑使用单例模式。</p>
<p>单例模式实现的要点是:<br>1.构造函数私有化，不对外开放<br>2.通过静态方法getInstance()或者枚举返回单例对象<br>3.确保在多线程环境下单例类对象有且只有一个<br>4.确保单例类对象在反序列化时不会重新构建对象</p>
<p>##下列几种单例模式是单例模式下最常见的几种写法</p>
<p>###饿汉模式 每次都创建一个对象来赋值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> mInstance: Singleton = Singleton()</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton &#123;</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###懒汉模式 不用每次都创建一个新的对象，可以复用已存在的对象, 缺点是同步锁导致性能降低<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mInstance: Singleton2</div><div class="line">        <span class="meta">@Synchronized</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton2 &#123;</div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</div><div class="line">                mInstance = Singleton2()</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###Double Check Lock 懒汉模式的升级版，不用每次都同步，在没有对象的时候才能同步,比懒汉模式的效率有提升,但这种单例模式还是有漏洞，存在一些问题<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mInstance: Singleton3</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton3 &#123;</div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>) &#123;</div><div class="line">                synchronized(Singleton3::<span class="class"><span class="keyword">class</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</div><div class="line">                        mInstance = Singleton3()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###静态内部类单例 可以延迟内部对象的生成，并且是线程安全<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Singleton4 &#123;</div><div class="line">            <span class="keyword">return</span> Singleton4Holder.mInstance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTestValue</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"内部方法"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4Holder</span> </span>&#123;</div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="keyword">internal</span> <span class="keyword">val</span> mInstance: Singleton4 = Singleton4()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###枚举单例 枚举在任何情况下都是一个实例，同时枚举是线程安全的类<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTestValue</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"内部方法"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：单例模式切忌使用于需要动态变化的实例场景下</p>
</blockquote>
<p><em>本文来自阅读《Android Source Design Patterns Analysis &amp; Practice》书籍的笔记</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#kotlin设计模式之单例模式&lt;/p&gt;
&lt;p&gt;##单例模式介绍&lt;/p&gt;
&lt;p&gt;单例模式在日常开发中是非常常见的写法，一般常见于全局只需要类保有一个对象实例用于使用的情景.避免了产生多个对象消耗过多的资源，或某种类型对象只应该有且只有一个。一般一个对象需要消耗的资源过多，比
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>灵活开发之面向对象的六大原则</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/12/%E7%81%B5%E6%B4%BB%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/12/灵活开发之面向对象的六大原则/</id>
    <published>2019-01-12T05:24:45.000Z</published>
    <updated>2019-01-12T05:44:37.682Z</updated>
    
    <content type="html"><![CDATA[<p>#灵活开发之面向对象的六大原则（SOLID原则 + 迪米特原则）</p>
<p>##单一职责原则-让代码更清晰<br>单一职责原则(Single Responsibility Principle)，简单来说一个类，一个函数只对应一种职责，只做一类事情。例如一个类里面不能包含多个完全不同类型功能的代码，同一个类应该保证方法对应的功能相关性高。但是单一职责原则划分界限不清晰，很多时候需要根据个人经验或者具体业务逻辑来界定。</p>
<p>##开闭原则-让程序更灵活、稳定<br>开闭原则(Open Close Principle)的定义是软件中的对象(类、模块、函数等)应对于扩展是开放的，对于修改是关闭的，也就是说编写代码的时候应该以编写新的扩展功能来替代在原代码上直接修改这种行为，因为软件的生命周期里出现变化、升级和维护都是必不可少的情况，直接在原代码基础上修改可能将原本无问题的代码引入错误进来，导致系统异常或者不稳定等情况。</p>
<p>##里氏替换原则-构建扩展性更好的系统<br>里氏替换原则(Liskov Substitution Principle)的定义是如果每个类型为S的对象obj1,都有类型为T的对象obj2，那么类型S是类型为T的子类。简单点说就是所有引用了父类对象的地方，都可以使用它的子类对象直接替代，这也是面向对象中的继承和多态的概念。<br>里氏替换原则的优缺点如下<br>优点：<br>1.代码重用性好，每个子类都可以直接继承父类的属性和方法，可直接使用父类属性和方法，也可重写父类方法<br>2.提高代码的可扩展性<br>缺点：<br>1.继承的侵入性，每个子类必需全部继承父类的所有属性和方法<br>2.因子类必需全部继承父类的所有属性和方法可能导致代码冗余、灵活性降低</p>
<p>##依赖倒置原则-让项目拥有变化的能力<br>依赖倒置原则(Dependence Inversion Principle)其实是一种解耦的形式，主要提出高层模块不应该依赖低层模块，两者都应该直接依赖其抽象，并且抽象不应该依赖于细节，而细节必须依赖抽象。该原则在java中的表现是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生<br>的。简单点说就是将细节实现业务抽象成一个或多个共有的接口，通过接入接口来实现具体的细节类，并且在引用该接口的地方直接传入实现该接口的子类实现类，就可以实现符合开闭原则的依赖替换原则。</p>
<blockquote>
<p>耦合问题: 如果类与类直接依赖于细节，那么它们之间就有直接的耦合，当具体实现需要变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。</p>
</blockquote>
<p>##接口隔离原则-系统有更高的灵活性<br>接口隔离原则(Interface Segregation Principles)的定义是实现类不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上，该原则将庞大、臃肿的接口拆分成更小更具体的接口，由客户来挑选了解他们感兴趣的方法。其实说简单了就是封装类提供出自己认为可以给客户使用的方法供客户使用，而不是将所有重要的或不被允许提供的方法提供给用户。</p>
<p>##迪米特原则-更好的可扩展性<br>迪米特原则(Law Of Demeter)也称为最少知识原则(Least Knowledge Principle)，该原则是指一个对象应该对其他对象有最少的了解，可就是说一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或依赖者无关，调用者或依赖者只需要知道它需要知道的方法即可，其他一概不用管。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><em>本文来自阅读《Android Source Design Patterns Analysis &amp; Practice》书籍的笔记</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#灵活开发之面向对象的六大原则（SOLID原则 + 迪米特原则）&lt;/p&gt;
&lt;p&gt;##单一职责原则-让代码更清晰&lt;br&gt;单一职责原则(Single Responsibility Principle)，简单来说一个类，一个函数只对应一种职责，只做一类事情。例如一个类里面不能包含
    
    </summary>
    
    
      <category term="开发原则" scheme="https://zealp.github.io/ZealP_Blog/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>2019 Kotlin Technology Stack</title>
    <link href="https://zealp.github.io/ZealP_Blog/2019/01/05/2019KotlinTechnologyStack/"/>
    <id>https://zealp.github.io/ZealP_Blog/2019/01/05/2019KotlinTechnologyStack/</id>
    <published>2019-01-05T15:10:48.000Z</published>
    <updated>2019-01-12T05:44:16.975Z</updated>
    
    <content type="html"><![CDATA[<p>#《2019 Kotlin Technology Stack》笔记集之设计模式</p>
<p><a href="https://zealp.github.io/ZealP_Blog/2016/06/11/%E7%81%B5%E6%B4%BB%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/">灵活开发之面向对象的六大原则</a></p>
<p><a href="https://zealp.github.io/ZealP_Blog/2019/01/05/kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">kotlin设计模式之单例模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#《2019 Kotlin Technology Stack》笔记集之设计模式&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zealp.github.io/ZealP_Blog/2016/06/11/%E7%81%B5%E6%B4%BB%E5%BC%80%E5%8F%9
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://zealp.github.io/ZealP_Blog/tags/Kotlin/"/>
    
  </entry>
  
</feed>
